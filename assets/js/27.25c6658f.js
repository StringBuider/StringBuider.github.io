(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{819:function(t,s,a){"use strict";a.r(s);var o=a(56),v=Object(o.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"微前端-版本管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微前端-版本管理"}},[t._v("#")]),t._v(" 微前端-版本管理")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("说明")]),t._v(" "),a("p",[t._v("该规范是指导性的故而不提供具体实践")])]),t._v(" "),a("h2",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("blockquote",[a("p",[t._v("为什么是版本管理？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("理想常态")]),t._v(" "),a("ClientOnly",[a("microfontends-version-g6",{attrs:{id:"status1"}})],1)],1),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("子应用不断自迭代更新")]),t._v(" "),a("ClientOnly",[a("microfontends-version-g6",{attrs:{id:"status2"}})],1)],1),t._v(" "),a("p",[t._v("微前端的聚合本质上是主应用动态加载线上子应用(js)，以上图示中，\n主应用下的2-子应用1.1不断自迭代，如何保证主应用的质量可控，如何接入的子应用数远大于图示呢？\n可以考量以下几个方面")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("对约定负责")])]),t._v(" "),a("p",[t._v("主应用与子应用，对"),a("code",[t._v("路由规则")]),t._v("、"),a("code",[t._v("有父子通讯的部分")]),t._v("等做出约定。发生新增、改动前需与主应用开发团队及时同步")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("保留线上旧版本")])]),t._v(" "),a("p",[t._v("主应用可以根据自己的迭代周期决定引入哪一版子应用，开发迭代中的质量管理")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);